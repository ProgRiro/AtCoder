h, w, k = map(int, input().split())

c = [0] * h

for i in range(h):
    c[i] = input()

cnt = 0

# ビット全探索
# 1 << h は 2^h と同意
# 初期値：0001=1、左に1bitシフトして0010=2、左に1bitシフトして0100=4、左に1bitシフトして1000=8
# 2 << h は 2^h と同意
# 初期値：0010=2、左に1bitシフトして0100=4、左に1bitシフトして1000=8、左に1bitシフトして10000=16
for rows in range(1 << h):  # どの行を使うか
    for cols in range(1 << w):  # どの列を使うか
        black = 0  # 黒の数
        # 全て見ていく
        for i in range(h):
            # rowsというbit列の i bit目が立っているかどうか
            # i 桁シフトして2で割った余りが1かどうか
            if(rows >> i) % 2 == 1:  # rowsというbit列のi bit目が立っているかどうか赤く塗られる
                continue
            # rows の i bit目が塗られていなかった場合、ここの処理に移る
            for j in range(w):
                # colsというbit列の j bit目が立っているかどうか
                # j 桁シフトして2で割った余りが1かどうか
                if(cols >> j) % 2 == 1:  # 赤く塗られる
                    continue
                # 生き残った奴は black の可能性がある
                black += c[i][j] == '#'
        if black == k:
            cnt += 1

# 外側のループ2つで、赤く塗られている場所（行と列）を確定させている
# 内側のループ2つで、赤く塗られている場所（行と列）を探索していく

# bit列と配列の要素の並びは逆転していると考える
# 0bit右シフト%2は0番目の要素に対応している
# 1bit右シフト%2は1番目の要素に対応している
# 2bit右シフト%2は2番目の要素に対応している
# 3bit右シフト%2は3番目の要素に対応している

print(cnt)

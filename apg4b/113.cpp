#define _GLIBCXX_DEBUG
#include <bits/stdc++.h>
using namespace std;

int main() {
  // 文字列
  string str;    // 文字列変数を宣言
  str = "abcd";  // 'a', 'b', 'c', 'd' という文字(char)の列を代入
  cout << str.at(0) << endl;   // 1つ目である'a'を出力
  cout << str.size() << endl;  // 文字列の長さである4を出力

  // 配列
  vector<int> vec;            // int型の配列変数vecを宣言
  vec = {25, 100, 64};        // 25, 100, 64 という整数(int)の列を代入
  cout << vec.at(0) << endl;  // 1つめである25を出力
  cout << vec.size() << endl;  // 配列の長さである3を出力

  // 100要素の配列で初期化
  vector<int> vec2(100);
  // 100個の入力を受け取る
  for (int i = 0; i < 100; i++) {
    cin >> vec2.at(i);
  }

  // vector<型> 配列名(要素数, 初期値);
  // vec.push_back(10);  // 末尾に10を追加
  // vec.pop_back();  // 末尾の要素を削除

  vector<int> vec3(3, 10);  // {10, 10, 10} で初期化
  vec3 = vector<int>(100, 2);  // 100要素の配列 {2, 2, ... , 2, 2} で上書き
}

/*
キーポイント
配列は様々なデータの列を扱うことができる機能
vector<型> 配列変数名;で配列変数を宣言できる
配列変数名 = { 要素1, 要素2, ... };で配列変数に値を代入できる
配列変数.at(i)でi番目の要素にアクセスできる
配列変数.size()で配列の要素数を取得できる
vector<型> 配列変数名(要素数)と書くと指定した要素数で配列を初期化できる
配列でN個の入力を受け取るときは、N要素で初期化した後、for文の中でatを使って1ずつ受け取る
*/

/*
atを使わないi番目の要素へのアクセス
今まで配列の要素を指定するときは配列変数.at(添字)と書いてきましたが、配列変数[添字]でも同じことができます。
ただし、この書き方は範囲外の添字を指定してしまったときにエラーメッセージを表示してくれず、
何が原因でプログラムが正しく動いていないのかがわかりにくいので、配列変数.at(添字)の書き方を使うようにしましょう。
*/

/*
安全に[]でi番目の要素へのアクセスする方法
ABC/ARCで他の人の提出を見ると[]を使っている人が多いです。
これは[]のほうが短くて読み書きしやすい、または最初に[]を学んで慣れているという理由からです。
先に述べたとおり[]はエラーが発見しにくいですが、#define
_GLIBCXX_DEBUGとコードの最初に書くことで
.atと同程度に安全に使うことができるようになります。
*/

/*
配列同士の比較
配列変数同士は==で比較することができます。==では2つの配列の全要素が一致していたとき、条件式は真になります。
ただし、比較する際はどちらも「配列変数」である必要があり、vec == { 1, 2, 3}
のようには書けないことに注意しましょう。
*/